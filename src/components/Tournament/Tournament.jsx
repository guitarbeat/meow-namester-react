/**
 * @module Tournament
 * @description A React component that handles the tournament-style voting interface for cat names.
 * Provides a UI for comparing two names, with options for liking both or neither.
 */
/**
 * --- AUTO-GENERATED DOCSTRING ---
 * Table of content is automatically generated by Agent Docstrings v1.3.5
 *
 * Classes/Functions:
 *   - useEffect(() => (line 126)
 *   - if (Array.isArray(names) && names.length > 0) (line 127)
 *   - setRandomizedNames(shuffleArray([...names])); (line 128)
 *   - useEffect(() => (line 181)
 *   - return () => (line 189)
 *   - if (musicRef.current) (line 190)
 *   - if (audioRef.current) (line 194)
 *   - for (const effect of soundEffects) (line 209)
 *   - if (random < effect.weight) (line 210)
 *   - if (!isMuted && audioRef.current) (line 221)
 *   - useEffect(() => (line 234)
 *   - const playNewTrack = async () => (line 235)
 *   - if (musicRef.current) (line 237)
 *   - if (!isMuted) (line 243)
 *   - setAudioError(null); (line 247)
 *   - setAudioError("Unable to play background music. Click to try again."); (line 250)
 *   - playNewTrack(); (line 254)
 *   - setIsMuted((prev) => (line 258)
 *   - if (newMuted) (line 261)
 *   - if (musicRef.current) (line 262)
 *   - if (audioRef.current) (line 265)
 *   - setAudioError("Unable to play audio. Click to try again."); (line 270)
 *   - setCurrentTrack((prev) => (prev + 1) % musicTracks.length); (line 281)
 *   - if (audioError && !isMuted && musicRef.current) (line 285)
 *   - setAudioError("Unable to play audio. Click to try again."); (line 291)
 *   - useEffect(() => (line 297)
 *   - if (isError) (line 298)
 *   - setSelectedOption(null); (line 299)
 *   - setIsTransitioning(false); (line 300)
 *   - setIsProcessing(false); (line 301)
 *   - setIsRandomizing(false); (line 302)
 *   - useEffect(() => (line 308)
 *   - if (currentMatch) (line 309)
 *   - if (tournamentStateRef.current.isActive) (line 322)
 *   - setIsRandomizing(true); (line 326)
 *   - setIsTransitioning(true); (line 327)
 *   - setTimeout(() => (line 329)
 *   - setRandomizedNames(shuffleArray([...names])); (line 330)
 *   - setIsRandomizing(false); (line 331)
 *   - setIsTransitioning(false); (line 332)
 *   - if (option === "both") (line 341)
 *   - setLastMatchResult(resultMessage); (line 351)
 *   - setTimeout(() => setShowMatchResult(true), 500); (line 354)
 *   - setTimeout(() => setShowMatchResult(false), 2500); (line 356)
 *   - if (isProcessing || isTransitioning || isError) (line 362)
 *   - setIsProcessing(true); (line 367)
 *   - setIsTransitioning(true); (line 368)
 *   - playSound(); (line 370)
 *   - updateMatchResult(option); (line 371)
 *   - if (onVote && currentMatch) (line 375)
 *   - switch (option) (line 383)
 *   - setSelectedOption(null); (line 431)
 *   - setIsProcessing(false); (line 434)
 *   - setIsTransitioning(false); (line 437)
 *   - setIsProcessing(false); (line 440)
 *   - setIsTransitioning(false); (line 441)
 *   - if (isProcessing || isTransitioning) (line 447)
 *   - setSelectedOption(option); (line 452)
 *   - handleVoteWithAnimation(option); (line 455)
 *   - setIsProcessing(true); (line 460)
 *   - if (currentRatings && Object.keys(currentRatings).length > 0) (line 462)
 *   - setIsProcessing(false); (line 468)
 *   - useEffect(() => (line 473)
 *   - const handleKeyPress = (e) => (line 474)
 *   - if (isProcessing || isTransitioning) (line 475)
 *   - switch (e.key) (line 479)
 *   - setSelectedOption("left"); (line 481)
 *   - if (audioRef.current && !isMuted) (line 482)
 *   - setSelectedOption("right"); (line 488)
 *   - if (audioRef.current && !isMuted) (line 489)
 *   - if (selectedOption) (line 495)
 *   - handleVoteWithAnimation(selectedOption); (line 496)
 *   - handleVoteWithAnimation("both"); (line 500)
 *   - handleVoteWithAnimation("neither"); (line 503)
 *   - return () => window.removeEventListener("keydown", handleKeyPress); (line 511)
 *   - const MatchResult = () => (line 515)
 *   - if (!showMatchResult || !lastMatchResult) (line 516)
 *   - setVolume((prev) => (line 533)
 *   - if (audioRef.current && type === "effects") (line 535)
 *   - if (musicRef.current && type === "music") (line 538)
 *   - if (vote.result < -0.1) (line 550)
 *   - if (isError) (line 570)
 *   - if (!currentMatch) (line 585)
 *   - function Tournament(props) (line 728)
 * --- END AUTO-GENERATED DOCSTRING ---
 */

import React, {
  useState,
  useCallback,
  useEffect,
  useRef,
  useMemo,
} from "react";
import PropTypes from "prop-types";
import { useTournament } from "../../hooks/useTournament";
import { useToast } from "../../hooks/useToast";
// import { useKeyboardControls } from '../../hooks/useKeyboardControls';
import LoadingSpinner from "../LoadingSpinner/LoadingSpinner";
import ErrorBoundary from "../ErrorBoundary/ErrorBoundary";
import NameCard from "../NameCard/NameCard";
import InlineError from "../InlineError/InlineError";
import Bracket from "../Bracket/Bracket";
import TournamentControls from "./TournamentControls";
import styles from "./Tournament.module.css";
import { shuffleArray } from "../../utils/arrayUtils";

function TournamentContent({
  onComplete,
  existingRatings = {},
  names = [],
  onVote,
}) {
  const [randomizedNames, setRandomizedNames] = useState([]);

  const tournamentStateRef = useRef({ isActive: false });

  useEffect(() => {
    if (Array.isArray(names) && names.length > 0) {
      setRandomizedNames(shuffleArray([...names]));
    }
  }, [names]);

  const {
    currentMatch,
    handleVote,
    progress,
    roundNumber,
    currentMatchNumber,
    totalMatches,
    matchHistory = [],
    getCurrentRatings,
    isError,
  } = useTournament({
    names: randomizedNames.length > 0 ? randomizedNames : names,
    existingRatings,
    onComplete,
  });

  const [selectedOption, setSelectedOption] = useState(null);
  const [isTransitioning, setIsTransitioning] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);
  const [isMuted, setIsMuted] = useState(false);
  const [volume, setVolume] = useState({ music: 0.2, effects: 0.3 });
  const [audioError, setAudioError] = useState(null);
  const audioRef = useRef(null);
  const musicRef = useRef(null);
  const [currentTrack, setCurrentTrack] = useState(0);
  const [lastMatchResult, setLastMatchResult] = useState(null);
  const [showMatchResult, setShowMatchResult] = useState(false);
  const [showBracket, setShowBracket] = useState(false);
  const [showRoundTransition, setShowRoundTransition] = useState(false);
  const [nextRoundNumber, setNextRoundNumber] = useState(null);
  const [votingError, setVotingError] = useState(null);

  // Toast notifications
  const { showSuccess, showError } = useToast();

  const musicTracks = useMemo(
    () => [
      { path: "/sounds/AdhesiveWombat - Night Shade.mp3", name: "Night Shade" },
      { path: "/sounds/MiseryBusiness.mp3", name: "Misery Business" },
      { path: "/sounds/what-is-love.mp3", name: "What is Love" },
      {
        path: "/sounds/Lemon Demon - The Ultimate Showdown (8-Bit Remix).mp3",
        name: "Ultimate Showdown (8-Bit)",
      },
      { path: "/sounds/Main Menu 1 (Ruins).mp3", name: "Ruins" },
    ],
    [],
  );

  // Sound effects configuration with updated weights
  const soundEffects = useMemo(
    () => [
      { path: "/sounds/gameboy-pluck.mp3", weight: 0.5 },
      { path: "/sounds/wow.mp3", weight: 0.2 },
      { path: "/sounds/surprise.mp3", weight: 0.1 },
      { path: "/sounds/level-up.mp3", weight: 0.2 },
    ],
    [],
  );

  // Initialize audio only once
  useEffect(() => {
    audioRef.current = new Audio(soundEffects[0].path);
    audioRef.current.volume = volume.effects;

    musicRef.current = new Audio(musicTracks[0].path);
    musicRef.current.volume = volume.music;
    musicRef.current.loop = true;

    return () => {
      if (musicRef.current) {
        musicRef.current.pause();
        musicRef.current = null;
      }
      if (audioRef.current) {
        audioRef.current.pause();
        audioRef.current = null;
      }
    };
  }, [musicTracks, soundEffects, volume.effects, volume.music]);

  // Function to pick a random sound effect based on weights
  const getRandomSoundEffect = useCallback(() => {
    const totalWeight = soundEffects.reduce(
      (sum, effect) => sum + effect.weight,
      0,
    );
    let random = Math.random() * totalWeight;

    for (const effect of soundEffects) {
      if (random < effect.weight) {
        return effect.path;
      }
      random -= effect.weight;
    }

    return soundEffects[0].path; // Fallback to default sound
  }, [soundEffects]);

  const playSound = useCallback(() => {
    try {
      if (!isMuted && audioRef.current) {
        const soundEffect = getRandomSoundEffect();
        audioRef.current.src = soundEffect;
        audioRef.current.currentTime = 0;
        audioRef.current.volume = volume.effects;
        audioRef.current.play();
      }
    } catch (error) {
      console.error("Error playing sound effect:", error);
    }
  }, [isMuted, volume.effects, getRandomSoundEffect]);

  // Handle track changes
  useEffect(() => {
    const playNewTrack = async () => {
      try {
        if (musicRef.current) {
          musicRef.current.pause();
          musicRef.current.src = musicTracks[currentTrack].path;
          musicRef.current.volume = volume.music;
          musicRef.current.loop = true;

          if (!isMuted) {
            await musicRef.current.play();
          }
        }
        setAudioError(null);
      } catch (error) {
        console.error("Error playing audio:", error);
        setAudioError("Unable to play background music. Click to try again.");
      }
    };

    playNewTrack();
  }, [currentTrack, isMuted, volume.music, musicTracks]);

  const handleToggleMute = useCallback(() => {
    setIsMuted((prev) => {
      const newMuted = !prev;
      try {
        if (newMuted) {
          if (musicRef.current) {
            musicRef.current.pause();
          }
          if (audioRef.current) {
            audioRef.current.pause();
          }
        } else if (musicRef.current) {
          musicRef.current.play().catch(() => {
            setAudioError("Unable to play audio. Click to try again.");
          });
        }
      } catch (error) {
        console.error("Error toggling mute:", error);
      }
      return newMuted;
    });
  }, []);

  const handleNextTrack = useCallback(() => {
    setCurrentTrack((prev) => (prev + 1) % musicTracks.length);
  }, [musicTracks.length]);

  const retryAudio = useCallback(() => {
    if (audioError && !isMuted && musicRef.current) {
      musicRef.current
        .play()
        .then(() => setAudioError(null))
        .catch((error) => {
          console.error("Error retrying audio:", error);
          setAudioError("Unable to play audio. Click to try again.");
        });
    }
  }, [audioError, isMuted]);

  // Reset state when error occurs
  useEffect(() => {
    if (isError) {
      setSelectedOption(null);
      setIsTransitioning(false);
      setIsProcessing(false);

      tournamentStateRef.current.isActive = false;
    }
  }, [isError]);

  // Track tournament state
  useEffect(() => {
    if (currentMatch) {
      tournamentStateRef.current.isActive = true;
    }
  }, [currentMatch]);

  // Track match results and tournament progress
  const updateMatchResult = useCallback(
    (option) => {
      let resultMessage = "";
      if (option === "both") {
        resultMessage = `Both "${currentMatch.left.name}" and "${currentMatch.right.name}" advance!`;
      } else if (option === "left") {
        resultMessage = `"${currentMatch.left.name}" wins this round!`;
      } else if (option === "right") {
        resultMessage = `"${currentMatch.right.name}" wins this round!`;
      } else if (option === "neither") {
        resultMessage = "Match skipped";
      }

      setLastMatchResult(resultMessage);

      // Show result after a short delay
      setTimeout(() => setShowMatchResult(true), 500);
      // Hide result after 2 seconds
      setTimeout(() => setShowMatchResult(false), 2500);
      
      // Show success toast for voting
      showSuccess('Vote recorded successfully!', { duration: 3000 });
    },
    [currentMatch],
  );

  const handleVoteWithAnimation = useCallback(
    async (option) => {
      if (isProcessing || isTransitioning || isError) {
        return;
      }

      try {
        setIsProcessing(true);
        setIsTransitioning(true);

        playSound();
        updateMatchResult(option);

        const updatedRatings = await handleVote(option);

        if (onVote && currentMatch) {
          const leftName = currentMatch.left.name;
          const rightName = currentMatch.right.name;

          // Improved vote tracking logic
          let leftOutcome = "skip";
          let rightOutcome = "skip";

          switch (option) {
            case "left":
              leftOutcome = "win";
              rightOutcome = "loss";
              break;
            case "right":
              leftOutcome = "loss";
              rightOutcome = "win";
              break;
            case "both":
              leftOutcome = "win";
              rightOutcome = "win";
              break;
            case "neither":
              // Both remain 'skip'
              break;
          }

          const voteData = {
            match: {
              left: {
                name: leftName,
                id: currentMatch.left.id, // Make sure ID is included
                description: currentMatch.left.description || "",
                outcome: leftOutcome,
              },
              right: {
                name: rightName,
                id: currentMatch.right.id, // Make sure ID is included
                description: currentMatch.right.description || "",
                outcome: rightOutcome,
              },
            },
            result:
              option === "left"
                ? -1
                : option === "right"
                  ? 1
                  : option === "both"
                    ? 0.5
                    : 0,
            ratings: updatedRatings,
            timestamp: new Date().toISOString(), // Add timestamp for better tracking
          };

          await onVote(voteData);
        }

        setSelectedOption(null);

        await new Promise((resolve) => setTimeout(resolve, 200));
        setIsProcessing(false);

        await new Promise((resolve) => setTimeout(resolve, 100));
        setIsTransitioning(false);
      } catch (error) {
        console.error("Error handling vote:", error);
        setVotingError({
          message: "Failed to submit vote. Please try again.",
          severity: "MEDIUM",
          isRetryable: true,
          originalError: error
        });
        
        // Show error toast
        showError('Failed to submit vote. Please try again.', { duration: 5000 });
        
        setIsProcessing(false);
        setIsTransitioning(false);
      }
    },
    [
      isProcessing,
      isTransitioning,
      isError,
      playSound,
      updateMatchResult,
      handleVote,
      onVote,
      currentMatch,
    ],
  );

  // Separate click handler for name cards
  const handleNameCardClick = useCallback(
    (option) => {
      if (isProcessing || isTransitioning) {
        return;
      }

      // Set the selected option first
      setSelectedOption(option);

      // Then trigger the vote
      handleVoteWithAnimation(option);
    },
    [isProcessing, isTransitioning, handleVoteWithAnimation],
  );

  const handleEndEarly = useCallback(async () => {
    try {
      setIsProcessing(true);
      const currentRatings = getCurrentRatings();
      if (currentRatings && Object.keys(currentRatings).length > 0) {
        await onComplete(currentRatings);
      }
    } catch (error) {
      console.error("Error ending tournament:", error);
    } finally {
      setIsProcessing(false);
    }
  }, [getCurrentRatings, onComplete]);

  const handleVoteRetry = useCallback(() => {
    setVotingError(null);
    // The user can try voting again by clicking on a name card
  }, []);

  // Add keyboard controls
  useEffect(() => {
    const handleKeyPress = (e) => {
      if (isProcessing || isTransitioning) {
        return;
      }

      switch (e.key) {
        case "ArrowLeft":
          setSelectedOption("left");
          if (audioRef.current && !isMuted) {
            audioRef.current.currentTime = 0;
            audioRef.current.play();
          }
          break;
        case "ArrowRight":
          setSelectedOption("right");
          if (audioRef.current && !isMuted) {
            audioRef.current.currentTime = 0;
            audioRef.current.play();
          }
          break;
        case " ":
          if (selectedOption) {
            handleVoteWithAnimation(selectedOption);
          }
          break;
        case "ArrowUp":
          handleVoteWithAnimation("both");
          break;
        case "ArrowDown":
          handleVoteWithAnimation("neither");
          break;
        default:
          break;
      }
    };

    window.addEventListener("keydown", handleKeyPress);
    return () => window.removeEventListener("keydown", handleKeyPress);
  }, [
    selectedOption,
    isProcessing,
    isTransitioning,
    handleVoteWithAnimation,
    isMuted,
  ]);

  // Match result component
  const MatchResult = () => {
    if (!showMatchResult || !lastMatchResult) {
      return null;
    }

    return (
      <div className={styles.matchResult} role="status" aria-live="polite">
        <div className={styles.resultContent}>
          <span className={styles.resultMessage}>{lastMatchResult}</span>
          <span className={styles.tournamentProgress}>
            Round {roundNumber} - Match {currentMatchNumber} of {totalMatches}
          </span>
        </div>
      </div>
    );
  };

  // Round transition component
  const RoundTransition = () => {
    if (!showRoundTransition || !nextRoundNumber) {
      return null;
    }

    return (
      <div className={styles.roundTransition} role="status" aria-live="polite">
        <div className={styles.transitionContent}>
          <div className={styles.roundIcon}>🏆</div>
          <h2 className={styles.roundTitle}>Round {nextRoundNumber}</h2>
          <p className={styles.roundSubtitle}>Tournament continues...</p>
        </div>
      </div>
    );
  };

  const handleVolumeChange = useCallback((type, value) => {
    setVolume((prev) => {
      const newVolume = { ...prev, [type]: value };
      if (audioRef.current && type === "effects") {
        audioRef.current.volume = value;
      }
      if (musicRef.current && type === "music") {
        musicRef.current.volume = value;
      }
      return newVolume;
    });
  }, []);

  // Transform match history for the Bracket component
  const transformedMatches = useMemo(() => {
    return matchHistory.map((vote, index) => {
      // Convert numeric result to winner format
      let winner;
      if (vote.result < -0.1) {
        winner = -1;
      } else if (vote.result > 0.1) {
        winner = 1;
      } else if (Math.abs(vote.result) <= 0.1) {
        winner = 0;
      } else {
        winner = 2;
      } // skip

      return {
        id: index + 1,
        name1: vote.match.left.name,
        name2: vote.match.right.name,
        winner,
      };
    });
  }, [matchHistory]);

  // Round transition effect
  useEffect(() => {
    if (roundNumber > 1) {
      setShowRoundTransition(true);
      setNextRoundNumber(roundNumber);

      // Hide transition after 2 seconds
      const timer = setTimeout(() => {
        setShowRoundTransition(false);
        setNextRoundNumber(null);
      }, 2000);

      return () => clearTimeout(timer);
    }
  }, [roundNumber]);

  // Add error UI
  if (isError) {
    return (
      <div className={styles.errorContainer}>
        <h3>Tournament Error</h3>
        <p>There was an error with the tournament. Please try again.</p>
        <button
          onClick={() => window.location.reload()}
          className={styles.retryButton}
        >
          Restart Tournament
        </button>
      </div>
    );
  }

  if (!currentMatch) {
    return <LoadingSpinner />;
  }

  return (
    <div className={styles.tournament} role="main" aria-live="polite">
      <div
        className={styles.progressInfo}
        role="status"
        aria-live="polite"
        aria-atomic="true"
      >
        <div className={styles.roundInfo}>
          <span className={styles.roundNumber}>Round {roundNumber}</span>
          <span className={styles.matchCount}>
            Match {currentMatchNumber} of {totalMatches}
          </span>
        </div>
        <div
          className={styles.percentageInfo}
          aria-label={`Tournament is ${progress}% complete`}
        >
          {progress}% Complete
        </div>
      </div>

      <TournamentControls
        onEndEarly={handleEndEarly}
        isTransitioning={isTransitioning || isProcessing}
        isMuted={isMuted}
        onToggleMute={handleToggleMute}
        onNextTrack={handleNextTrack}
        currentTrack={currentTrack}
        trackInfo={musicTracks[currentTrack]}
        audioError={audioError}
        onRetryAudio={retryAudio}
        volume={volume}
        onVolumeChange={handleVolumeChange}
      />

      <div className={styles.tournamentLayout}>
        <div
          className={styles.matchup}
          role="region"
          aria-label="Current matchup"
          aria-busy={isTransitioning || isProcessing}
        >
          <div className={styles.namesRow}>
            <div
              className={`${styles.nameContainer} ${selectedOption === "left" ? styles.selected : ""}`}
              role="group"
              aria-label="Left name option"
            >
              <NameCard
                name={currentMatch.left.name}
                description={currentMatch.left.description}
                onClick={() => handleNameCardClick("left")}
                selected={selectedOption === "left"}
                disabled={isProcessing || isTransitioning}
                shortcutHint="Press ← arrow key"
                size="medium"
              />
            </div>

            <div className={styles.vsSection} aria-hidden="true">
              <span className={styles.vsText}>vs</span>
            </div>

            <div
              className={`${styles.nameContainer} ${selectedOption === "right" ? styles.selected : ""}`}
              role="group"
              aria-label="Right name option"
            >
              <NameCard
                name={currentMatch.right.name}
                description={currentMatch.right.description}
                onClick={() => handleNameCardClick("right")}
                selected={selectedOption === "right"}
                disabled={isProcessing || isTransitioning}
                shortcutHint="Press → arrow key"
                size="medium"
              />
            </div>
          </div>

          <div
            className={styles.extraOptions}
            role="group"
            aria-label="Additional voting options"
          >
            <button
              className={`${styles.extraOptionsButton} ${selectedOption === "both" ? styles.selected : ""}`}
              onClick={() => handleVoteWithAnimation("both")}
              disabled={isProcessing || isTransitioning}
              aria-pressed={selectedOption === "both"}
              type="button"
            >
              I Like Both! <span className={styles.shortcutHint}>(↑ Up)</span>
            </button>

            <button
              className={`${styles.extraOptionsButton} ${selectedOption === "neither" ? styles.selected : ""}`}
              onClick={() => handleVoteWithAnimation("neither")}
              disabled={isProcessing || isTransitioning}
              aria-pressed={selectedOption === "neither"}
              type="button"
            >
              Skip <span className={styles.shortcutHint}>(↓ Down)</span>
            </button>
          </div>

          {/* Voting error display */}
          {votingError && (
            <InlineError
              error={votingError}
              context="vote"
              position="below"
              onRetry={handleVoteRetry}
              onDismiss={() => setVotingError(null)}
              showRetry={true}
              showDismiss={true}
              size="medium"
              className={styles.votingError}
            />
          )}
        </div>

        <button
          className={styles.bracketToggle}
          onClick={() => setShowBracket(!showBracket)}
          aria-expanded={showBracket}
          aria-controls="bracketView"
        >
          {showBracket ? "Hide Tournament History" : "Show Tournament History"}
          <span className={styles.bracketToggleIcon}>
            {showBracket ? "▼" : "▶"}
          </span>
        </button>

        {showBracket && (
          <div
            id="bracketView"
            className={styles.bracketView}
            role="complementary"
            aria-label="Tournament bracket history"
          >
            <Bracket matches={transformedMatches} />
          </div>
        )}
      </div>

      {/* Replace name insight with match result */}
      <MatchResult />
      <RoundTransition />
    </div>
  );
}

function Tournament(props) {
  return (
    <ErrorBoundary>
      <TournamentContent {...props} />
    </ErrorBoundary>
  );
}

Tournament.displayName = "Tournament";

Tournament.propTypes = {
  names: PropTypes.array,
  existingRatings: PropTypes.object,
  onComplete: PropTypes.func,
  userName: PropTypes.string,
  onVote: PropTypes.func,
};

export default Tournament;
