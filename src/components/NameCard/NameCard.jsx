/**
 * @module NameCard
 * @description A reusable card component for displaying name options
 * with consistent styling and behavior across the application.
 */
/**
 * --- AUTO-GENERATED DOCSTRING ---
 * Table of content is automatically generated by Agent Docstrings v1.3.5
 *
 * Classes/Functions:
 *   - useEffect(() => (line 66)
 *   - if (isRippling) (line 67)
 *   - return () => clearTimeout(timer); (line 69)
 *   - useEffect(() => (line 74)
 *   - if (!card || disabled) return; (line 76)
 *   - const handleMouseMove = (e) => (line 78)
 *   - setMousePosition( (line 100)
 *   - if (card) (line 103)
 *   - const handleMouseLeave = () => (line 109)
 *   - setMousePosition( (line 114)
 *   - if (card) (line 117)
 *   - return () => (line 126)
 *   - const handleInteraction = (event) => (line 132)
 *   - if (disabled) (line 133)
 *   - setIsRippling(true); (line 153)
 *   - const getAriaLabel = () => (line 159)
 *   - if (description) (line 161)
 *   - if (isSelected) (line 164)
 *   - if (disabled) (line 167)
 *   - const getSafeId = (text) => (line 174)
 * --- END AUTO-GENERATED DOCSTRING ---
 */

import React, { useState, useEffect, useRef } from "react";
import PropTypes from "prop-types";
import styles from "./NameCard.module.css";

/**
 * NameCard Component
 * @param {Object} props
 * @param {string} props.name - The name to display in the card
 * @param {string} [props.description] - Optional description text
 * @param {boolean} [props.isSelected] - Whether the card is selected
 * @param {Function} [props.onClick] - Click handler function
 * @param {boolean} [props.disabled=false] - Whether the card is disabled
 * @param {string} [props.shortcutHint] - Keyboard shortcut hint
 * @param {string} [props.className=''] - Additional CSS classes
 * @param {('small'|'medium')} [props.size='medium'] - Card size variant
 */
function NameCard({
  name,
  description,
  isSelected,
  onClick,
  disabled = false,
  shortcutHint,
  className = "",
  size = "medium",
}) {
  const [rippleStyle, setRippleStyle] = useState({});
  const [isRippling, setIsRippling] = useState(false);
  const [tiltStyle, setTiltStyle] = useState({});
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
  const cardRef = useRef(null);

  useEffect(() => {
    if (isRippling) {
      const timer = setTimeout(() => setIsRippling(false), 600);
      return () => clearTimeout(timer);
    }
  }, [isRippling]);

  // Tilt effect and mouse follow
  useEffect(() => {
    const card = cardRef.current;
    if (!card || disabled) return;

    const handleMouseMove = (e) => {
      const rect = card.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // Calculate center of card
      const centerX = rect.width / 2;
      const centerY = rect.height / 2;

      // Calculate tilt angles (max 15 degrees)
      const tiltX = ((y - centerY) / centerY) * -15;
      const tiltY = ((x - centerX) / centerX) * 15;

      // Calculate mouse position for background effect
      const mouseX = (x / rect.width) * 100;
      const mouseY = (y / rect.height) * 100;

      setTiltStyle({
        transform: `perspective(1000px) rotateX(${tiltX}deg) rotateY(${tiltY}deg) scale3d(1.05, 1.05, 1.05)`,
        transition: "transform 0.1s ease-out",
      });

      setMousePosition({ x: mouseX, y: mouseY });

      // Set CSS custom properties for mouse position
      if (card) {
        card.style.setProperty("--mouse-x", `${mouseX}%`);
        card.style.setProperty("--mouse-y", `${mouseY}%`);
      }
    };

    const handleMouseLeave = () => {
      setTiltStyle({
        transform:
          "perspective(1000px) rotateX(0deg) rotateY(0deg) scale3d(1, 1, 1)",
        transition: "transform 0.5s ease-out",
      });
      setMousePosition({ x: 50, y: 50 });

      // Reset CSS custom properties
      if (card) {
        card.style.setProperty("--mouse-x", "50%");
        card.style.setProperty("--mouse-y", "50%");
      }
    };

    card.addEventListener("mousemove", handleMouseMove);
    card.addEventListener("mouseleave", handleMouseLeave);

    return () => {
      card.removeEventListener("mousemove", handleMouseMove);
      card.removeEventListener("mouseleave", handleMouseLeave);
    };
  }, [disabled]);

  const handleInteraction = (event) => {
    if (disabled) {
      return;
    }

    if (
      event.type === "click" ||
      (event.type === "keydown" && (event.key === "Enter" || event.key === " "))
    ) {
      event.preventDefault();

      // Create ripple effect
      const rect = event.currentTarget.getBoundingClientRect();
      const x = event.clientX ? event.clientX - rect.left : rect.width / 2;
      const y = event.clientY ? event.clientY - rect.top : rect.height / 2;

      setRippleStyle({
        left: `${x}px`,
        top: `${y}px`,
      });

      setIsRippling(true);
      onClick?.();
    }
  };

  // Enhanced accessibility for button state
  const getAriaLabel = () => {
    let label = name;
    if (description) {
      label += ` - ${description}`;
    }
    if (isSelected) {
      label += " (selected)";
    }
    if (disabled) {
      label += " (disabled)";
    }
    return label;
  };

  // Generate safe ID for aria-describedby
  const getSafeId = (text) => {
    return text.replace(/[^a-zA-Z0-9]/g, "-").toLowerCase();
  };

  const cardClasses = [
    styles.card,
    styles[size],
    isSelected && styles.selected,
    disabled && styles.disabled,
    className,
  ]
    .filter(Boolean)
    .join(" ");

  return (
    <button
      ref={cardRef}
      className={cardClasses}
      onClick={handleInteraction}
      onKeyDown={handleInteraction}
      disabled={disabled}
      aria-pressed={isSelected}
      aria-label={getAriaLabel()}
      aria-describedby={
        description ? `${getSafeId(name)}-description` : undefined
      }
      type="button"
      style={tiltStyle}
    >
      {/* Background mouse follow effect */}
      <div
        className={styles.backgroundEffect}
        style={{
          background: `radial-gradient(circle at ${mousePosition.x}% ${mousePosition.y}%, rgba(var(--primary-rgb), 0.1) 0%, transparent 50%)`,
          opacity: disabled ? 0 : 1,
        }}
      />

      <h3 className={styles.name}>{name}</h3>
      {description && (
        <p id={`${getSafeId(name)}-description`} className={styles.description}>
          {description}
        </p>
      )}
      {shortcutHint && (
        <span className={styles.shortcutHint} aria-hidden="true">
          {shortcutHint}
        </span>
      )}
      {isSelected && (
        <span className={styles.checkMark} aria-hidden="true">
          âœ“
        </span>
      )}
      {isRippling && (
        <span
          className={styles.rippleEffect}
          style={rippleStyle}
          aria-hidden="true"
        />
      )}
    </button>
  );
}

NameCard.propTypes = {
  name: PropTypes.string.isRequired,
  description: PropTypes.string,
  isSelected: PropTypes.bool,
  onClick: PropTypes.func,
  disabled: PropTypes.bool,
  shortcutHint: PropTypes.string,
  className: PropTypes.string,
  size: PropTypes.oneOf(["small", "medium"]),
};

export default NameCard;
