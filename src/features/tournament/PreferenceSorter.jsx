/**
 * @module PreferenceSorter
 * @description A class that implements a merge sort algorithm with custom comparisons
 * for sorting cat names based on user preferences.
 */
/**
 * --- AUTO-GENERATED DOCSTRING ---
 * Table of content is automatically generated by Agent Docstrings v1.3.5
 *
 * Classes/Functions:
 *   - PreferenceSorter (line 36):
 *     - constructor(items) (line 37)
 *     - if (!Array.isArray(items)) (line 38)
 *     - getName(item) (line 51)
 *     - addPreference(item1, item2, value) (line 55)
 *   - getPreference(item1, item2) (line 60)
 *   - if (this.preferences.has(key)) (line 70)
 *   - getCurrentRankings() (line 82)
 *   - if (this.ranks.length > 0) (line 83)
 *   - async sort(compareCallback) (line 89)
 *   - if (!this.rec || this.rec.length !== n) (line 92)
 *   - async sortRecursive(left, right, compareCallback) (line 100)
 *   - if (right - left < 1) (line 101)
 *   - if (left === right) (line 102)
 *   - async mergeSubGroups(left, mid, right, compareCallback) (line 114)
 *   - while (i <= mid && j <= right) (line 119)
 *   - if (result <= -0.5) (line 123)
 *   - while (i <= mid) (line 140)
 *   - while (j <= right) (line 143)
 *   - for (let k = 0; k < merged.length; k++) (line 147)
 *   - if (left === 0 && right === this.items.length - 1) (line 152)
 * --- END AUTO-GENERATED DOCSTRING ---
 */

export class PreferenceSorter {
  constructor(items) {
    if (!Array.isArray(items)) {
      throw new Error('PreferenceSorter requires an array of items');
    }
    this.items = items;
    this.preferences = new Map();
    this.currentRankings = [...items];
    this.ranks = [];
    this.rec = new Array(items.length).fill(0);
    // Pairwise comparison queue (simple, reliable fallback)
    this.pairs = [];
    for (let i = 0; i < items.length - 1; i++) {
      for (let j = i + 1; j < items.length; j++) {
        this.pairs.push([this.getName(items[i]), this.getName(items[j])]);
      }
    }
    this.currentIndex = 0;
    this.history = [];
  }

  getName(item) {
    return typeof item === 'string' ? item : item.name;
  }

  addPreference(item1, item2, value) {
    const key = `${this.getName(item1)}-${this.getName(item2)}`;
    this.preferences.set(key, value);
    // Record history for undo support
    this.history.push({
      a: this.getName(item1),
      b: this.getName(item2),
      value
    });
  }

  getPreference(item1, item2) {
    const key = `${this.getName(item1)}-${this.getName(item2)}`;
    const reverseKey = `${this.getName(item2)}-${this.getName(item1)}`;

    if (this.preferences.has(key)) {
      return this.preferences.get(key);
    } else if (this.preferences.has(reverseKey)) {
      return -this.preferences.get(reverseKey);
    } else {
      return 0;
    }
  }

  getCurrentRankings() {
    if (this.ranks.length > 0) {
      return this.ranks;
    }
    return this.currentRankings;
  }

  async sort(compareCallback) {
    const n = this.items.length;

    if (!this.rec || this.rec.length !== n) {
      this.rec = new Array(n).fill(0);
    }

    await this.sortRecursive(0, n - 1, compareCallback);
    return this.ranks;
  }

  async sortRecursive(left, right, compareCallback) {
    if (right - left < 1) {
      if (left === right) {
        this.ranks.push(this.items[left]);
      }
      return;
    }

    const mid = Math.floor((left + right) / 2);
    await this.sortRecursive(left, mid, compareCallback);
    await this.sortRecursive(mid + 1, right, compareCallback);
    await this.mergeSubGroups(left, mid, right, compareCallback);
  }

  async mergeSubGroups(left, mid, right, compareCallback) {
    let i = left;
    let j = mid + 1;
    const merged = [];

    while (i <= mid && j <= right) {
      try {
        const result = await compareCallback(this.items[i], this.items[j]);

        if (result <= -0.5) {
          merged.push(this.items[i++]);
        } else if (result >= 0.5) {
          merged.push(this.items[j++]);
        } else if (result < 0) {
          merged.push(this.items[i++]);
          merged.push(this.items[j++]);
        } else {
          merged.push(this.items[j++]);
          merged.push(this.items[i++]);
        }
      } catch (error) {
        console.error('Comparison failed:', error);
        // Handle cancellation or fallback strategy
      }
    }

    while (i <= mid) {
      merged.push(this.items[i++]);
    }
    while (j <= right) {
      merged.push(this.items[j++]);
    }

    for (let k = 0; k < merged.length; k++) {
      this.items[left + k] = merged[k];
      this.currentRankings[left + k] = merged[k];
    }

    if (left === 0 && right === this.items.length - 1) {
      this.ranks = [...merged];
    }
  }

  // Return the next un-judged pair as a match { left, right }
  getNextMatch() {
    // Advance index to next pair we haven't judged yet
    while (this.currentIndex < this.pairs.length) {
      const [a, b] = this.pairs[this.currentIndex];
      const key = `${a}-${b}`;
      const reverseKey = `${b}-${a}`;
      if (!this.preferences.has(key) && !this.preferences.has(reverseKey)) {
        return { left: a, right: b };
      }
      this.currentIndex++;
    }
    return null;
  }

  // Undo last added preference
  undoLastPreference() {
    const last = this.history.pop();
    if (!last) return;
    const key = `${last.a}-${last.b}`;
    const reverseKey = `${last.b}-${last.a}`;
    this.preferences.delete(key);
    this.preferences.delete(reverseKey);
    // Step back at least one index to revisit the undone pair if needed
    this.currentIndex = Math.max(0, this.currentIndex - 1);
  }
}
