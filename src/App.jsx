/**
 * @module App
 * @description Main application component for the cat name tournament app.
 * Manages the overall application state and tournament flow, including:
 * - Name input and management
 * - Tournament progression
 * - Rating calculations
 * - Results display
 *
 * Uses the Elo rating system for ranking and a custom sorting algorithm
 * for determining the best cat name through user preferences.
 *
 * @component
 * @returns {JSX.Element} The complete application UI
 */
/**
 * --- AUTO-GENERATED DOCSTRING ---
 * Table of content is automatically generated by Agent Docstrings v1.3.5
 *
 * Classes/Functions:
 *   - function App() (line 105)
 *   - if (savedTheme) (line 116)
 *   - useEffect(() => (line 123)
 *   - if (themeColorMeta) (line 128)
 *   - useEffect(() => (line 137)
 *   - const handleThemeChange = (isLight) => (line 144)
 *   - setIsLightTheme(isLight); (line 145)
 *   - useEffect(() => (line 149)
 *   - if (view !== "tournament") (line 150)
 *   - setTournamentNames(null); (line 151)
 *   - setTournamentComplete(false); (line 152)
 *   - const handleVoteHistoryUpdate = (newVote) => (line 157)
 *   - setVoteHistory((prev) => [...prev, newVote]); (line 158)
 *   - const handleTournamentComplete = async (finalRatings) => (line 161)
 *   - if (!userName) (line 163)
 *   - if (!tournamentResults[left.name]) (line 188)
 *   - if (!tournamentResults[right.name]) (line 191)
 *   - if (result < -0.1) (line 196)
 *   - if (nameError) (line 214)
 *   - if (!name_id) (line 229)
 *   - if (recordsToUpsert.length > 0) (line 253)
 *   - if (upsertError) (line 261)
 *   - if (name) (line 272)
 *   - setRatings(updatedRatings); (line 281)
 *   - setTournamentComplete(true); (line 285)
 *   - const handleStartNewTournament = () => (line 291)
 *   - setTournamentComplete(false); (line 292)
 *   - setTournamentNames(null); (line 293)
 *   - setView("tournament"); (line 294)
 *   - const handleTournamentSetup = (names) => (line 297)
 *   - setIsTournamentLoading(true); (line 298)
 *   - const handleUpdateRatings = async (adjustedRatings) => (line 312)
 *   - if (nameError) (line 333)
 *   - if (recordsToUpsert.length === 0) (line 347)
 *   - if (upsertError) (line 359)
 *   - setRatings(updatedRatings); (line 364)
 *   - const handleLogout = async () => (line 372)
 *   - logout(); (line 373)
 *   - const handleMatrixActivate = () => (line 377)
 *   - setMatrixMode(true); (line 378)
 *   - setTimeout(() => setMatrixMode(false), 5000); // Disable after 5 seconds (line 379)
 *   - useEffect(() => (line 383)
 *   - if (!isLoggedIn) (line 384)
 *   - setView("tournament"); (line 385)
 *   - setTournamentComplete(false); (line 386)
 *   - setTournamentNames(null); (line 387)
 *   - setVoteHistory([]); (line 388)
 *   - useEffect(() => (line 393)
 *   - if (tournamentNames === null) (line 394)
 *   - setIsTournamentLoading(false); (line 395)
 *   - setIsTournamentLoading(tournamentNames.length === 0); (line 397)
 *   - const renderMainContent = () => (line 401)
 *   - if (!isLoggedIn) (line 402)
 *   - switch (view) (line 406)
 *   - if (tournamentComplete) (line 423)
 *   - if (tournamentNames === null) (line 436)
 * --- END AUTO-GENERATED DOCSTRING ---
 */

import React, { useState, useEffect, Suspense } from "react";
import { ErrorBoundary, Login, ErrorDisplay, OnboardingModal } from "./components";
import NavBar from "./components/NavBar/NavBar";
import useUserSession from "./hooks/useUserSession";
import useErrorHandler from "./hooks/useErrorHandler";
import useOnboarding from "./hooks/useOnboarding";
import { supabase } from "./supabase/supabaseClient";
import LoadingSpinner from "./components/LoadingSpinner/LoadingSpinner";
import FloatingKitties from "./components/FloatingKitties";

// Lazy-loaded components for performance
const Results = React.lazy(() => import("./components/Results/Results"));
const Profile = React.lazy(() => import("./components/Profile/Profile"));
const TournamentSetup = React.lazy(
  () => import("./components/TournamentSetup/TournamentSetup")
);
const Tournament = React.lazy(
  () => import("./components/Tournament/Tournament")
);

function App() {
  const { userName, isLoggedIn, login, logout } = useUserSession();
  
  // Onboarding management
  const {
    showOnboarding,
    closeOnboarding,
    dontShowAgain,
  } = useOnboarding();
  
  // Enhanced error handling
  const {
    errors,
    isError,
    handleError,
    clearErrors,
    clearError,
    executeWithErrorHandling
  } = useErrorHandler({
    showUserFeedback: true,
    maxRetries: 3,
    onError: (error) => {
      console.error('App-level error:', error);
    },
    onRecovery: () => {
      console.log('App recovered from error');
    }
  });

  const [ratings, setRatings] = useState({});
  const [view, setView] = useState("tournament");
  const [tournamentComplete, setTournamentComplete] = useState(false);
  const [tournamentNames, setTournamentNames] = useState(null);
  const [voteHistory, setVoteHistory] = useState([]);

  const [isTournamentLoading, setIsTournamentLoading] = useState(false);

  // Reset tournament state when changing views
  useEffect(() => {
    if (view !== "tournament") {
      setTournamentNames(null);
      setTournamentComplete(false);
    }
  }, [view]);

  // Handle vote history updates
  const handleVoteHistoryUpdate = (newVote) => {
    setVoteHistory((prev) => [...prev, newVote]);
  };

  const handleTournamentComplete = async (finalRatings) => {
    try {
      if (!userName) {
        console.error("No user name available");
        return;
      }

      // Convert finalRatings to array if it's an object
      const ratingsArray = Array.isArray(finalRatings)
        ? finalRatings
        : Object.entries(finalRatings).map(([name, rating]) => ({
            name,
            rating,
          }));

      // Initialize tournament results for all names
      const tournamentResults = {};
      ratingsArray.forEach((rating) => {
        tournamentResults[rating.name] = { wins: 0, losses: 0 };
      });

      // Process vote history to count wins and losses
      voteHistory.forEach((vote) => {
        const { match, result } = vote;
        const { left, right } = match;

        // Initialize if not exists (safety check)
        if (!tournamentResults[left.name]) {
          tournamentResults[left.name] = { wins: 0, losses: 0 };
        }
        if (!tournamentResults[right.name]) {
          tournamentResults[right.name] = { wins: 0, losses: 0 };
        }

        // Update based on numeric result
        if (result < -0.1) {
          // left won (using threshold to account for floating point)
          tournamentResults[left.name].wins++;
          tournamentResults[right.name].losses++;
        } else if (result > 0.1) {
          // right won
          tournamentResults[right.name].wins++;
          tournamentResults[left.name].losses++;
        }
        // For values near 0 (both/none), we don't update wins/losses
      });

      // Get name_ids from cat_name_options table
      const { data: nameOptions, error: nameError } = await supabase
        .from("cat_name_options")
        .select("id, name")
        .in("name", Object.keys(tournamentResults));

      if (nameError) {
        handleError(nameError, 'Tournament Completion - Fetch Names', {
          isRetryable: true,
          affectsUserData: false,
          isCritical: false
        });
        return;
      }

      // Create a map of name to name_id
      const nameToIdMap = nameOptions.reduce((acc, { id, name }) => {
        acc[name] = id;
        return acc;
      }, {});

      // Prepare records for database update
      const recordsToUpsert = Object.entries(tournamentResults)
        .map(([name, results]) => {
          const name_id = nameToIdMap[name];
          if (!name_id) {
            console.warn(`No name_id found for ${name}`);
            return null;
          }

          // Get the final rating for this name
          const finalRating =
            ratingsArray.find((r) => r.name === name)?.rating || 1500;

          // Get existing rating data
          const existingRating = ratings[name] || { wins: 0, losses: 0 };

          return {
            user_name: userName,
            name_id,
            rating: Math.round(finalRating),
            // Add new wins/losses to existing totals
            wins: (existingRating.wins || 0) + results.wins,
            losses: (existingRating.losses || 0) + results.losses,
            updated_at: new Date().toISOString(),
          };
        })
        .filter(Boolean);

      if (recordsToUpsert.length > 0) {
        const { error: upsertError } = await supabase
          .from("cat_name_ratings")
          .upsert(recordsToUpsert, {
            onConflict: "user_name,name_id",
            returning: "minimal",
          });

        if (upsertError) {
          handleError(upsertError, 'Tournament Completion - Update Ratings', {
            isRetryable: true,
            affectsUserData: true,
            isCritical: false
          });
          return;
        }

        // Update local state with new ratings
        const updatedRatings = { ...ratings };
        recordsToUpsert.forEach((record) => {
          const name = nameOptions.find(
            (opt) => opt.id === record.name_id
          )?.name;
          if (name) {
            updatedRatings[name] = {
              rating: record.rating,
              wins: record.wins,
              losses: record.losses,
            };
          }
        });

        setRatings(updatedRatings);
      }

      // Set tournament as complete
      setTournamentComplete(true);
    } catch (error) {
      console.error("Error in tournament completion:", error);
    }
  };

  const handleStartNewTournament = () => {
    setTournamentComplete(false);
    setTournamentNames(null);
    setView("tournament");
  };

  const handleTournamentSetup = (names) => {
    setIsTournamentLoading(true);

    // Set names directly without delay
    setTournamentNames(
      names.map((n) => ({
        id: n.id,
        name: n.name,
        description: n.description,
        rating: ratings[n.name]?.rating || 1500,
      }))
    );
  };

  // Simplified ratings update logic
  const handleUpdateRatings = async (adjustedRatings) => {
    try {
      // Convert array format to consistent object format
      const updatedRatings = adjustedRatings.reduce(
        (acc, { name, rating, wins = 0, losses = 0 }) => {
          acc[name] = {
            rating: Math.round(rating),
            wins: wins,
            losses: losses,
          };
          return acc;
        },
        {}
      );

      // Get name_ids in a single query
      const { data: nameOptions, error: nameError } = await supabase
        .from("cat_name_options")
        .select("id, name")
        .in("name", Object.keys(updatedRatings));

      if (nameError) {
        throw nameError;
      }

      // Create records for database update
      const recordsToUpsert = nameOptions.map(({ id, name }) => ({
        user_name: userName,
        name_id: id,
        rating: updatedRatings[name].rating,
        wins: updatedRatings[name].wins,
        losses: updatedRatings[name].losses,
        updated_at: new Date().toISOString(),
      }));

      if (recordsToUpsert.length === 0) {
        throw new Error("No valid records to update");
      }

      // Update database
      const { error: upsertError } = await supabase
        .from("cat_name_ratings")
        .upsert(recordsToUpsert, {
          onConflict: "user_name,name_id",
          returning: "minimal",
        });

      if (upsertError) {
        throw upsertError;
      }

      // Update local state
      setRatings(updatedRatings);
      return true;
    } catch (error) {
      console.error("Error updating ratings:", error);
      throw error;
    }
  };

  const handleLogout = async () => {
    logout();
  };

  // Add effect to handle authentication state
  useEffect(() => {
    if (!isLoggedIn) {
      setView("tournament");
      setTournamentComplete(false);
      setTournamentNames(null);
      setVoteHistory([]);
    }
  }, [isLoggedIn]);

  // Update loading state effect
  useEffect(() => {
    if (tournamentNames === null) {
      setIsTournamentLoading(false);
    } else {
      setIsTournamentLoading(tournamentNames.length === 0);
    }
  }, [tournamentNames]);

  const renderMainContent = () => {
    if (!isLoggedIn) {
      return <Login onLogin={login} />;
    }

    switch (view) {
      case "profile":
        return (
          <Profile
            userName={userName}
            onStartNewTournament={handleStartNewTournament}
            ratings={ratings}
            onUpdateRatings={handleUpdateRatings}
          />
        );
      case "loading":
        return (
          <div className="fullScreenCenter">
            <LoadingSpinner size="large" text="Testing Loading Spinner..." />
          </div>
        );
      case "tournament":
        if (tournamentComplete) {
          return (
            <Results
              ratings={ratings}
              onStartNew={handleStartNewTournament}
              userName={userName}
              onUpdateRatings={handleUpdateRatings}
              currentTournamentNames={tournamentNames}
              voteHistory={voteHistory}
            />
          );
        }

        if (tournamentNames === null) {
          return (
            <TournamentSetup
              onStart={handleTournamentSetup}
              userName={userName}
              existingRatings={ratings}
            />
          );
        }

        return (
          <ErrorBoundary>
            <Tournament
              names={tournamentNames}
              existingRatings={ratings}
              onComplete={handleTournamentComplete}
              userName={userName}
              onVote={handleVoteHistoryUpdate}
            />
          </ErrorBoundary>
        );
      default:
        return null;
    }
  };

  return (
    <div className="app">
      {/* Skip link for keyboard navigation */}
      <a href="#main-content" className="skip-link">
        Skip to main content
      </a>
      
      {/* * Floating kitties background */}
      <FloatingKitties
        kittieCount={12}
        creationInterval={3000}
        minSize={20}
        maxSize={35}
        minDuration={4}
        maxDuration={10}
        backgroundImage="galaxy"
        enableGlow={true}
        enableHover={true}
      />

      <NavBar
        view={view}
        setView={setView}
        isLoggedIn={isLoggedIn}
        userName={userName}
        onLogout={handleLogout}
        onStartNewTournament={handleStartNewTournament}
      />
      <div id="main-content" className="main-content" tabIndex="-1">
        {/* Global error display */}
        {isError && (
          <ErrorDisplay
            errors={errors}
            onRetry={(error) => {
              // Implement retry logic based on error context
              if (error.context.includes('Tournament')) {
                window.location.reload();
              }
            }}
            onDismiss={clearError}
            onClearAll={clearErrors}
            showDetails={process.env.NODE_ENV === 'development'}
            className="global-error-display"
          />
        )}
        
        <Suspense fallback={<LoadingSpinner size="large" text="Loading..." />}>
          {renderMainContent()}
        </Suspense>
      </div>

      {isTournamentLoading && (
        <div
          className="global-loading-overlay"
          role="status"
          aria-live="polite"
          aria-busy="true"
        >
          <LoadingSpinner text="Initializing Tournament..." />
        </div>
      )}

      {/* Onboarding Modal */}
      <OnboardingModal
        isOpen={showOnboarding}
        onClose={closeOnboarding}
        onDontShowAgain={dontShowAgain}
      />
    </div>
  );
}

export default App;
