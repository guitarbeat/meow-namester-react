/**
 * @module useSupabaseStorage
 * @description A custom React hook that provides persistent storage using Supabase.
 * Manages real-time synchronization of data between the client and Supabase backend.
 */
/**
 * --- AUTO-GENERATED DOCSTRING ---
 * Table of content is automatically generated by Agent Docstrings v1.3.5
 *
 * Classes/Functions:
 *   - function useSupabaseStorage(tableName, initialValue = [], userName = "") (line 50)
 *   - setLoading(true); (line 57)
 *   - if (nameError) (line 71)
 *   - if (hiddenError) (line 80)
 *   - if (ratingsError) (line 103)
 *   - setStoredValue(processedData); (line 132)
 *   - setError(err); (line 135)
 *   - setLoading(false); (line 137)
 *   - useEffect(() => (line 141)
 *   - if (!userName) (line 142)
 *   - fetchData(); (line 145)
 *   - fetchData(); (line 159)
 *   - return () => (line 164)
 *   - async function setValue(newValue) (line 169)
 *   - if (!userName) (line 170)
 *   - if (nameError) (line 185)
 *   - if (missingNames.length > 0) (line 193)
 *   - if (insertError) (line 198)
 *   - if (fetchError) (line 209)
 *   - if (deleteError) (line 241)
 *   - if (dataToInsert.length > 0) (line 246)
 *   - if (insertError) (line 251)
 *   - setStoredValue(newValue); (line 257)
 *   - setError(err); (line 260)
 *   - async function hideName(nameId) (line 265)
 *   - if (!userName) (line 266)
 *   - if (error) (line 278)
 *   - setError(err); (line 286)
 *   - async function unhideName(nameId) (line 291)
 *   - if (!userName) (line 292)
 *   - if (error) (line 303)
 *   - setError(err); (line 311)
 * --- END AUTO-GENERATED DOCSTRING ---
 */

import { useState, useEffect, useCallback } from "react";
import { supabase } from "./supabaseClient";
import { DEFAULT_RATING } from "../components/Profile/Profile";

function useSupabaseStorage(tableName, initialValue = [], userName = "") {
  const [storedValue, setStoredValue] = useState(initialValue);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  const fetchData = useCallback(async () => {
    try {
      setLoading(true);

      // 1. First fetch all names
      const { data: nameData, error: nameError } = await supabase
        .from("name_options")
        .select(
          `
          id,
          name,
          description
        `,
        )
        .order("name");

      if (nameError) {
        throw nameError;
      }

      // 2. Fetch all hidden name IDs
      const { data: hiddenData, error: hiddenError } = await supabase
        .from("hidden_names")
        .select("name_id");

      if (hiddenError) {
        throw hiddenError;
      }

      // 3. Create a Set of hidden IDs for efficient lookup
      const hiddenIdSet = new Set(
        hiddenData?.map((item) => item.name_id) || [],
      );

      // 4. Filter out hidden names
      const visibleNames =
        nameData?.filter((item) => !hiddenIdSet.has(item.id)) || [];

      // 5. Fetch user ratings for these names
      const { data: ratingsData, error: ratingsError } = await supabase
        .from("cat_name_ratings")
        .select("name_id, rating, wins, losses, updated_at")
        .eq("user_name", userName)
        .in(
          "name_id",
          visibleNames.map((item) => item.id),
        );

      if (ratingsError) {
        throw ratingsError;
      }

      // 6. Create a map of ratings by name_id
      const ratingsMap = (ratingsData || []).reduce((map, item) => {
        map[item.name_id] = item;
        return map;
      }, {});

      // 7. Combine the data
      const processedData = visibleNames.map((item) => {
        const ratingData = ratingsMap[item.id];

        const wins = parseInt(ratingData?.wins || 0, 10);
        const losses = parseInt(ratingData?.losses || 0, 10);

        return {
          id: item.id,
          name: item.name,
          description: item.description,
          rating: parseInt(ratingData?.rating || DEFAULT_RATING, 10),
          wins,
          losses,
          updated_at: ratingData?.updated_at || new Date().toISOString(),
          hasRating: !!ratingData,
        };
      });

      setStoredValue(processedData);
    } catch (err) {
      console.error("Error fetching data:", err);
      setError(err);
    } finally {
      setLoading(false);
    }
  }, [userName]);

  useEffect(() => {
    if (!userName) {
      return;
    }
    fetchData();

    // Set up real-time subscription
    const subscription = supabase
      .channel(`${tableName}_changes`)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: tableName,
          filter: userName ? `user_name=eq.${userName}` : undefined,
        },
        () => {
          fetchData();
        },
      )
      .subscribe();

    return () => {
      subscription.unsubscribe();
    };
  }, [tableName, userName, fetchData]);

  async function setValue(newValue) {
    if (!userName) {
      return;
    }

    try {
      // First, ensure all names exist in name_options
      const names = Array.isArray(newValue)
        ? newValue.map((v) => v.name)
        : [newValue.name];

      const { data: existingNames, error: nameError } = await supabase
        .from("name_options")
        .select("id, name")
        .in("name", names);

      if (nameError) {
        throw nameError;
      }

      // Create any missing names
      const existingNameSet = new Set(existingNames.map((n) => n.name));
      const missingNames = names.filter((name) => !existingNameSet.has(name));

      if (missingNames.length > 0) {
        const { error: insertError } = await supabase
          .from("name_options")
          .insert(missingNames.map((name) => ({ name })));

        if (insertError) {
          throw insertError;
        }
      }

      // Now fetch the complete list to get all IDs
      const { data: allNames, error: fetchError } = await supabase
        .from("name_options")
        .select("id, name")
        .in("name", names);

      if (fetchError) {
        throw fetchError;
      }

      // Create a map of name to ID
      const nameToIdMap = allNames.reduce((acc, { id, name }) => {
        acc[name] = id;
        return acc;
      }, {});

      // Prepare the data for insertion
      const dataToInsert = (
        Array.isArray(newValue) ? newValue : [newValue]
      ).map((item) => ({
        name_id: nameToIdMap[item.name],
        user_name: userName,
        rating: item.rating || DEFAULT_RATING,
        wins: item.wins || 0,
        losses: item.losses || 0,
        updated_at: new Date().toISOString(),
      }));

      // Delete existing ratings for these names
      const { error: deleteError } = await supabase
        .from("cat_name_ratings")
        .delete()
        .eq("user_name", userName)
        .in(
          "name_id",
          dataToInsert.map((item) => item.name_id),
        );

      if (deleteError) {
        throw deleteError;
      }

      // Insert new ratings
      if (dataToInsert.length > 0) {
        const { error: insertError } = await supabase
          .from("cat_name_ratings")
          .insert(dataToInsert);

        if (insertError) {
          throw insertError;
        }
      }

      // Update local state
      setStoredValue(newValue);
    } catch (err) {
      console.error("Error setting value:", err);
      setError(err);
      throw err;
    }
  }

  async function hideName(nameId) {
    if (!userName) {
      return;
    }

    try {
      const { error } = await supabase.from("hidden_names").insert({
        name_id: nameId,
        user_name: userName,
      });

      if (error) {
        throw error;
      }

      // Refresh data to reflect changes
      await fetchData();
    } catch (err) {
      console.error("Error hiding name:", err);
      setError(err);
      throw err;
    }
  }

  async function unhideName(nameId) {
    if (!userName) {
      return;
    }

    try {
      const { error } = await supabase
        .from("hidden_names")
        .delete()
        .eq("name_id", nameId)
        .eq("user_name", userName);

      if (error) {
        throw error;
      }

      // Refresh data to reflect changes
      await fetchData();
    } catch (err) {
      console.error("Error unhiding name:", err);
      setError(err);
      throw err;
    }
  }

  return {
    storedValue,
    setValue,
    hideName,
    unhideName,
    loading,
    error,
    fetchData,
  };
}

export default useSupabaseStorage;
