import { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { PreferenceSorter } from '../components/Tournament/PreferenceSorter';
import EloRating from '../components/Tournament/EloRating';
import useLocalStorage from './useLocalStorage';
import useUserSession from './useUserSession';
import {
  /**
   * --- AUTO-GENERATED DOCSTRING ---
   * Table of content is automatically generated by Agent Docstrings v1.3.5
   *
   * Classes/Functions:
   *   - setTournamentState((prev) => ( (line 134)
   *   - useEffect(() => (line 145)
   *   - if (tournamentState.userName !== (userName || "anonymous")) (line 146)
   *   - useEffect(() => (line 158)
   *   - if (!Array.isArray(names) || names.length < 2) (line 159)
   *   - setIsError(true); (line 161)
   *   - setIsError(false); (line 163)
   *   - if (!left || !right) (line 184)
   *   - setCurrentMatch( (line 187)
   *   - setResolveVote(() => resolve); (line 189)
   *   - setTimeout(() => reject(new Error("Tournament timeout")), 300000), // 5 minute timeout (line 194)
   *   - onComplete(ratingsArray); (line 224)
   *   - setIsError(true); (line 227)
   *   - setCurrentMatch(null); (line 231)
   *   - setIsTransitioning(false); (line 232)
   *   - setRoundNumber(1); (line 233)
   *   - setCurrentMatchNumber(1); (line 235)
   *   - updateTournamentState( (line 236)
   *   - setCanUndo(false); (line 238)
   *   - useEffect(() => (line 244)
   *   - if (!names || names.length === 0) (line 245)
   *   - setSorter(newSorter); (line 251)
   *   - setTotalMatches(estimatedMatches); (line 264)
   *   - setCurrentMatchNumber(1); (line 265)
   *   - setRoundNumber(1); (line 266)
   *   - setCanUndo(false); (line 267)
   *   - setCurrentRatings(existingRatings); (line 268)
   *   - runTournament(newSorter); (line 270)
   *   - const countPlayerVotes = (playerName, outcome) => (line 275)
   *   - if (outcome === "win") (line 278)
   *   - if (outcome === "loss") (line 284)
   *   - if (isTransitioning || !resolveVote || isError) (line 324)
   *   - setIsTransitioning(true); (line 329)
   *   - switch (result) (line 334)
   *   - if (sorter) (line 385)
   *   - updateTournamentState((prev) => ( (line 419)
   *   - setCurrentRatings((prev) => ( (line 426)
   *   - setCanUndo(true); (line 442)
   *   - resolveVote(voteValue); (line 443)
   *   - if (currentMatchNumber >= totalMatches) (line 445)
   *   - onComplete(finalRatings); (line 447)
   *   - setCurrentMatchNumber((prev) => prev + 1); (line 451)
   *   - if (names.length > 2) (line 453)
   *   - if (currentMatchNumber % matchesPerRound === 0) (line 455)
   *   - setRoundNumber(newRound); (line 457)
   *   - updateTournamentState((prev) => ( (line 458)
   *   - setIsTransitioning(false); (line 467)
   *   - return () => clearTimeout(timeoutId); (line 470)
   *   - setIsError(true); (line 473)
   *   - setIsTransitioning(false); (line 474)
   *   - if (isTransitioning || !canUndo || matchHistory.length === 0) (line 499)
   *   - setIsTransitioning(true); (line 503)
   *   - setCurrentMatch(lastVote.match); (line 506)
   *   - setCurrentMatchNumber(lastVote.matchNumber); (line 507)
   *   - updateTournamentState( (line 509)
   *   - if (sorter) (line 511)
   *   - if (currentMatchNumber % Math.ceil(names.length / 2) === 1) (line 515)
   *   - setRoundNumber((prev) => prev - 1); (line 516)
   *   - setCanUndo(matchHistory.length > 1); (line 519)
   *   - setTimeout(() => (line 521)
   *   - setIsTransitioning(false); (line 522)
   *   - if (isError) (line 528)
   * --- END AUTO-GENERATED DOCSTRING ---
   */
  computeRating
  // countPlayerVotes,
  // getCurrentRatings,
  // convertVoteToPreference,
  // createVoteData,
  // calculateEstimatedMatches,
  // shouldIncrementRound,
  // createTournamentState,
} from '../utils/tournamentUtils';

export function useTournament({
  names = [],
  existingRatings = {},
  onComplete
}) {
  const { userName } = useUserSession();

  // Create a stable storage key using the names array and user name
  const tournamentId = useMemo(() => {
    const sortedNames = [...names]
      .map((n) => n.name)
      .sort()
      .join('-');
    const userPrefix = userName || 'anonymous';
    return `tournament-${userPrefix}-${sortedNames}`;
  }, [names, userName]);

  // Core tournament state
  const [currentMatch, setCurrentMatch] = useState(null);
  const [isTransitioning, setIsTransitioning] = useState(false);
  const [roundNumber, setRoundNumber] = useState(1);
  const [currentMatchNumber, setCurrentMatchNumber] = useState(1);
  const [totalMatches, setTotalMatches] = useState(1);
  const [sorter, setSorter] = useState(null);
  const [elo] = useState(() => new EloRating());
  const [resolveVote, setResolveVote] = useState(null);
  const [canUndo, setCanUndo] = useState(false);
  const [currentRatings, setCurrentRatings] = useState(existingRatings);
  const [isError, setIsError] = useState(false);

  // Use useLocalStorage for persistent tournament state
  const [tournamentState, setTournamentState] = useLocalStorage(tournamentId, {
    matchHistory: [],
    currentRound: 1,
    currentMatch: 1,
    totalMatches: 0,
    userName: userName || 'anonymous', // Store user context with tournament
    lastUpdated: Date.now(),
    namesKey: '' // Track when names actually change
  });

  // Destructure match history from tournament state
  const { matchHistory } = tournamentState;

  // Update tournament state helper
  const updateTournamentState = useCallback(
    (updates) => {
      setTournamentState((prev) => ({
        ...prev,
        ...updates,
        lastUpdated: Date.now(),
        userName: userName || 'anonymous'
      }));
    },
    [userName] // Remove setTournamentState as it's stable
  );

  // Reset tournament state when user changes
  useEffect(() => {
    if (tournamentState.userName !== (userName || 'anonymous')) {
      updateTournamentState({
        matchHistory: [],
        currentRound: 1,
        currentMatch: 1,
        totalMatches: 0,
        userName: userName || 'anonymous',
        namesKey: ''
      });
    }
  }, [userName, tournamentState.userName, updateTournamentState]);

  // Cleanup tournament state on unmount
  useEffect(() => {
    return () => {
      // Clear any pending operations
      if (resolveVote) {
        resolveVote(0); // Resolve with neutral vote to prevent hanging
      }
      // Reset state
      setCurrentMatch(null);
      setIsTransitioning(false);
      setCurrentMatchNumber(1);
      setRoundNumber(1);
    };
  }, [resolveVote]);

  // Validate names array when it changes
  useEffect(() => {
    if (!Array.isArray(names) || names.length < 2) {
      console.error('Invalid names array:', names);
      setIsError(true);
    } else {
      setIsError(false);
    }
  }, [names]);

  // Define runTournament before it is referenced by effects
  const runTournament = useCallback(
    async (tournamentSorter) => {
      try {
        const initialState = {
          names,
          existingRatings,
          currentMatchNumber: 1,
          roundNumber: 1,
          matchHistory: []
        };
        localStorage.setItem('tournamentState', JSON.stringify(initialState));

        // Add timeout to prevent infinite waiting
        const sortedResults = await Promise.race([
          tournamentSorter.sort(async (leftName, rightName) => {
            const left = names.find((n) => n.name === leftName);
            const right = names.find((n) => n.name === rightName);
            if (!left || !right) {
              throw new Error('Invalid match pair');
            }
            setCurrentMatch({ left, right });
            return new Promise((resolve) => {
              setResolveVote(() => resolve);
            });
          }),
          new Promise(
            (_, reject) =>
              setTimeout(() => reject(new Error('Tournament timeout')), 300000) // 5 minute timeout
          )
        ]);

        const ratingsArray = sortedResults.map((name, index) => {
          const existingData =
            typeof existingRatings[name] === 'object'
              ? existingRatings[name]
              : { rating: existingRatings[name] || 1500, wins: 0, losses: 0 };

          const totalNames = sortedResults.length;
          const position = index;
          const finalRating = computeRating(
            existingData.rating,
            position,
            totalNames,
            currentMatchNumber,
            totalMatches
          );

          return {
            name,
            rating: finalRating,
            wins: existingData.wins,
            losses: existingData.losses,
            confidence: currentMatchNumber / totalMatches
          };
        });

        localStorage.removeItem('tournamentState');
        onComplete(ratingsArray);
      } catch (error) {
        if (process.env.NODE_ENV === 'development') {
          console.error('Tournament completion error:', error);
        }
        setIsError(true);
        // Clear tournament state on error
        localStorage.removeItem('tournamentState');
        // Reset all state
        setCurrentMatch(null);
        setIsTransitioning(false);
        setRoundNumber(1);

        setCurrentMatchNumber(1);
        updateTournamentState({ matchHistory: [] });

        setCanUndo(false);
        throw error; // Propagate error to parent
      }
    },
    [names, existingRatings, onComplete] // Remove unstable dependencies
  );

  // Use ref to track if we've already initialized for current names
  const initializedNamesRef = useRef('');

  // Reset tournament state when names change
  useEffect(() => {
    const initializeTournament = async () => {
      console.log('[DEV] ðŸŽ® useTournament: useEffect triggered with names:', names);

      if (!names || names.length === 0) {
        console.log('[DEV] ðŸŽ® useTournament: No names provided, returning early');
        return;
      }

      const namesKey = names.map(n => n.id || n.name).join(',');
      console.log('[DEV] ðŸŽ® useTournament: Names key:', namesKey);

      // * FIXED: Remove the overly aggressive initialization check
      // * This was preventing the tournament from starting when names were the same
      // * We want to initialize every time names are provided
      console.log('[DEV] ðŸŽ® useTournament: Initializing tournament with names:', names);
      initializedNamesRef.current = namesKey;

          const nameStrings = names.map((n) => n.name);
      const newSorter = new PreferenceSorter(nameStrings);
      setSorter(newSorter);

      const n = names.length;
      const estimatedMatches = n <= 2 ? 1 : Math.ceil(n * Math.log2(n));

      // Reset tournament state
      updateTournamentState({
        matchHistory: [],
        currentRound: 1,
        currentMatch: 1,
        totalMatches: estimatedMatches,
        namesKey
      });

      setTotalMatches(estimatedMatches);
      setCurrentMatchNumber(1);
      setRoundNumber(1);
      setCanUndo(false);
      setCurrentRatings(existingRatings);

      // Run tournament with new sorter
      console.log('[DEV] ðŸŽ® useTournament: About to call runTournament with sorter:', newSorter);
      try {
        await runTournament(newSorter);
        console.log('[DEV] ðŸŽ® useTournament: runTournament completed successfully');
      } catch (error) {
        console.error('[DEV] ðŸŽ® useTournament: runTournament failed:', error);
      }
    };

    initializeTournament();
  }, [names, existingRatings, updateTournamentState, runTournament]);

  // Define getCurrentRatings first since it's used in handleVote
  const getCurrentRatings = useCallback(() => {
    const countPlayerVotes = (playerName, outcome) => {
      return matchHistory.filter((vote) => {
        const { left, right } = vote.match;
        if (outcome === 'win') {
          return (
            (left.name === playerName && vote.result === 'left') ||
            (right.name === playerName && vote.result === 'right')
          );
        }
        if (outcome === 'loss') {
          return (
            (left.name === playerName && vote.result === 'right') ||
            (right.name === playerName && vote.result === 'left')
          );
        }
        return false;
      }).length;
    };

    return names.map((name) => {
      const existingData =
        typeof currentRatings[name.name] === 'object'
          ? currentRatings[name.name]
          : { rating: currentRatings[name.name] || 1500, wins: 0, losses: 0 };

      const wins = countPlayerVotes(name.name, 'win');
      const losses = countPlayerVotes(name.name, 'loss');
      const position = wins; // Position is based on wins

      const finalRating = computeRating(
        existingData.rating,
        position,
        names.length,
        currentMatchNumber,
        totalMatches
      );

      return {
        name: name.name,
        rating: finalRating,
        wins: existingData.wins + wins,
        losses: existingData.losses + losses,
        confidence: currentMatchNumber / totalMatches
      };
    });
  }, [names, currentRatings, matchHistory, currentMatchNumber, totalMatches]);

  const handleVote = useCallback(
    (result) => {
      if (isTransitioning || !resolveVote || isError) {
        return;
      }

      try {
        setIsTransitioning(true);

        // Convert vote to preference value for PreferenceSorter
        let voteValue;
        let eloOutcome;
        switch (result) {
          case 'left':
            voteValue = -1;
            eloOutcome = 'left';
            break;
          case 'right':
            voteValue = 1;
            eloOutcome = 'right';
            break;
          case 'both': // Both equally liked with small random variance
            voteValue = Math.random() * 0.1 - 0.05; // Small random value centered at 0
            eloOutcome = 'both';
            break;
          case 'none': // Neither liked with small random variance
            voteValue = Math.random() * 0.06 - 0.03; // Even smaller random value centered at 0
            eloOutcome = 'none';
            break;
          default:
            voteValue = 0;
            eloOutcome = 'none';
        }

        // Update Elo ratings
        const leftName = currentMatch.left.name;
        const rightName = currentMatch.right.name;

        const leftRating = currentRatings[leftName]?.rating || 1500;
        const rightRating = currentRatings[rightName]?.rating || 1500;

        const leftStats = {
          winsA: currentRatings[leftName]?.wins || 0,
          lossesA: currentRatings[leftName]?.losses || 0,
          winsB: currentRatings[rightName]?.wins || 0,
          lossesB: currentRatings[rightName]?.losses || 0
        };

        const {
          newRatingA: updatedLeftRating,
          newRatingB: updatedRightRating,
          winsA: newLeftWins,
          lossesA: newLeftLosses,
          winsB: newRightWins,
          lossesB: newRightLosses
        } = elo.calculateNewRatings(
          leftRating,
          rightRating,
          eloOutcome,
          leftStats
        );

        // Update PreferenceSorter
        if (sorter) {
          sorter.addPreference(leftName, rightName, voteValue);
        }

        const voteData = {
          matchNumber: currentMatchNumber,
          result: voteValue,
          timestamp: Date.now(),
          userName: userName || 'anonymous',
          match: {
            left: {
              name: leftName,
              description: currentMatch.left.description || '',
              won: eloOutcome === 'left' || eloOutcome === 'both'
            },
            right: {
              name: rightName,
              description: currentMatch.right.description || '',
              won: eloOutcome === 'right' || eloOutcome === 'both'
            }
          },
          ratings: {
            before: {
              left: leftRating,
              right: rightRating
            },
            after: {
              left: updatedLeftRating,
              right: updatedRightRating
            }
          }
        };

        // Update tournament state with new vote and ratings
        updateTournamentState((prev) => ({
          ...prev,
          matchHistory: [...prev.matchHistory, voteData],
          currentMatch: currentMatchNumber + 1
        }));

        // Update current ratings with new ratings and win/loss counts
        setCurrentRatings((prev) => ({
          ...prev,
          [leftName]: {
            ...prev[leftName],
            rating: updatedLeftRating,
            wins: newLeftWins,
            losses: newLeftLosses
          },
          [rightName]: {
            ...prev[rightName],
            rating: updatedRightRating,
            wins: newRightWins,
            losses: newRightLosses
          }
        }));

        setCanUndo(true);
        resolveVote(voteValue);

        if (currentMatchNumber >= totalMatches) {
          const finalRatings = getCurrentRatings();
          onComplete(finalRatings);
          return;
        }

        setCurrentMatchNumber((prev) => prev + 1);

        if (names.length > 2) {
          const matchesPerRound = Math.ceil(names.length / 2);
          if (currentMatchNumber % matchesPerRound === 0) {
            const newRound = roundNumber + 1;
            setRoundNumber(newRound);
            updateTournamentState((prev) => ({
              ...prev,
              currentRound: newRound
            }));
          }
        }

        // Ensure transition state is cleared
        const timeoutId = setTimeout(() => {
          setIsTransitioning(false);
        }, 500);

        return () => clearTimeout(timeoutId);
      } catch (error) {
        console.error('Vote handling error:', error);
        setIsError(true);
        setIsTransitioning(false);
      }
    },
    [
      resolveVote,
      isTransitioning,
      currentMatchNumber,
      totalMatches,
      names.length,
      currentMatch,
      onComplete,
      getCurrentRatings,
      isError,
      roundNumber,
      updateTournamentState,
      userName,
      currentRatings,
      elo,
      sorter
    ]
  );

  // (runTournament defined above)

  const handleUndo = useCallback(() => {
    if (isTransitioning || !canUndo || matchHistory.length === 0) {
      return;
    }

    setIsTransitioning(true);

    const lastVote = matchHistory[matchHistory.length - 1];
    setCurrentMatch(lastVote.match);
    setCurrentMatchNumber(lastVote.matchNumber);

    updateTournamentState({ matchHistory: matchHistory.slice(0, -1) });

    if (sorter) {
      sorter.undoLastPreference();
    }

    if (currentMatchNumber % Math.ceil(names.length / 2) === 1) {
      setRoundNumber((prev) => prev - 1);
    }

    setCanUndo(matchHistory.length > 1);

    setTimeout(() => {
      setIsTransitioning(false);
    }, 500);
  }, [
    isTransitioning,
    canUndo,
    matchHistory,
    names.length,
    sorter,
    currentMatchNumber,
    updateTournamentState
  ]);

  const progress = Math.round((currentMatchNumber / totalMatches) * 100);

  if (isError) {
    return {
      currentMatch: null,
      handleVote: () => {},
      progress: 0,
      roundNumber: 0,
      currentMatchNumber: 0,
      totalMatches: 0,
      matchHistory: [],
      getCurrentRatings: () => [],
      isError: true,
      userName: tournamentState.userName
    };
  }

  return {
    currentMatch,
    isTransitioning,
    roundNumber,
    currentMatchNumber,
    totalMatches,
    progress,
    handleVote,
    handleUndo,
    canUndo,
    getCurrentRatings,
    isError,
    matchHistory: tournamentState.matchHistory,
    userName: tournamentState.userName
  };
}
